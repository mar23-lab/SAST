name: CI Pipeline

on:
  push:
    branches: [ main, develop, 'release/*', 'feature/*' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  CONFIG_FILE: 'ci-config.yaml'

jobs:
  load-config:
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.parse-config.outputs.config }}
      environment_config: ${{ steps.parse-env-config.outputs.env_config }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Parse configuration
        id: parse-config
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          config=$(cat ci-config.yaml | yq -o=json)
          echo "config=$config" >> $GITHUB_OUTPUT
      
      - name: Parse environment-specific config
        id: parse-env-config
        env:
          ENV_NAME: ${{ github.event.inputs.environment || 'development' }}
        run: |
          env_config=$(cat ci-config.yaml | yq ".environments.$ENV_NAME" -o=json)
          echo "env_config=$env_config" >> $GITHUB_OUTPUT

  build-and-test:
    needs: load-config
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: ${{ fromJson(needs.load-config.outputs.config).pipeline.matrix.os }}
        node-version: ${{ fromJson(needs.load-config.outputs.config).pipeline.matrix.node_version }}
        python-version: ${{ fromJson(needs.load-config.outputs.config).pipeline.matrix.python_version }}
    
    timeout-minutes: ${{ fromJson(needs.load-config.outputs.config).pipeline.timeouts.total_pipeline }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            ~/.cache/pip
            node_modules
            .cache
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json', '**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies
        run: |
          # Install Node.js dependencies if package.json exists
          if [ -f "package.json" ]; then
            npm ci
          fi
          
          # Install Python dependencies if requirements.txt exists
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi
          
          # Install Go dependencies if go.mod exists
          if [ -f "go.mod" ]; then
            go mod download
          fi

      - name: Run linting
        run: |
          # Run ESLint for JavaScript/TypeScript
          if [ -f "package.json" ] && npm list eslint &>/dev/null; then
            npm run lint || true
          fi
          
          # Run flake8 for Python
          if [ -f "requirements.txt" ]; then
            pip install flake8
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          fi
          
          # Run golangci-lint for Go
          if [ -f "go.mod" ]; then
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
            golangci-lint run || true
          fi

      - name: Run unit tests
        run: |
          # Run Jest tests for Node.js
          if [ -f "package.json" ] && npm list jest &>/dev/null; then
            npm test
          fi
          
          # Run pytest for Python
          if [ -f "requirements.txt" ]; then
            pip install pytest pytest-cov
            pytest --cov=. --cov-report=xml || true
          fi
          
          # Run Go tests
          if [ -f "go.mod" ]; then
            go test -v -race -coverprofile=coverage.out ./...
          fi

      - name: Upload test coverage
        if: always()
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml,./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  dependency-scan:
    needs: load-config
    runs-on: ubuntu-latest
    if: fromJson(needs.load-config.outputs.config).security.dependency_scanning.enabled
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Dependency Scanning
        run: |
          # Scan npm dependencies
          if [ -f "package.json" ]; then
            npm audit --audit-level=moderate --json > npm-audit.json || true
          fi
          
          # Scan Python dependencies with safety
          if [ -f "requirements.txt" ]; then
            pip install safety
            safety check --json > safety-report.json || true
          fi
          
          # Scan Go dependencies with govulncheck
          if [ -f "go.mod" ]; then
            go install golang.org/x/vuln/cmd/govulncheck@latest
            govulncheck ./... || true
          fi

      - name: Upload dependency scan results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: dependency-scan-results
          path: |
            npm-audit.json
            safety-report.json

  secret-scan:
    needs: load-config
    runs-on: ubuntu-latest
    if: fromJson(needs.load-config.outputs.config).security.secret_scanning.enabled
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run TruffleHog for secret scanning
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

      - name: Run GitLeaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-artifacts:
    needs: [load-config, build-and-test]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: hashFiles('package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Build application
        run: |
          if [ -f "package.json" ]; then
            npm ci
            npm run build
          fi
          
          if [ -f "Dockerfile" ]; then
            echo "Docker build would be triggered here"
          fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts-${{ github.sha }}
          path: |
            dist/
            build/
            target/
          retention-days: 30

  quality-gates:
    needs: [load-config, build-and-test, dependency-scan, secret-scan]
    runs-on: ubuntu-latest
    if: fromJson(needs.load-config.outputs.config).security.quality_gates.enabled
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          path: ./artifacts

      - name: Evaluate quality gates
        run: |
          # Load quality gate thresholds from config
          config='${{ needs.load-config.outputs.config }}'
          coverage_threshold=$(echo $config | jq -r '.security.quality_gates.coverage_threshold')
          
          echo "Evaluating quality gates..."
          echo "Coverage threshold: $coverage_threshold%"
          
          # Placeholder for actual quality gate evaluation
          # This would typically integrate with SonarQube, CodeClimate, etc.
          
          # For now, we'll simulate a successful quality gate
          echo "✅ All quality gates passed"

  notify-status:
    needs: [load-config, build-and-test, dependency-scan, secret-scan, quality-gates]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine overall status
        id: status
        run: |
          # Check if all jobs succeeded
          if [[ "${{ needs.build-and-test.result }}" == "success" && 
                "${{ needs.dependency-scan.result }}" != "failure" && 
                "${{ needs.secret-scan.result }}" != "failure" && 
                "${{ needs.quality-gates.result }}" != "failure" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ CI Pipeline completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ CI Pipeline failed - check logs for details" >> $GITHUB_OUTPUT
          fi

      - name: Send notifications
        if: fromJson(needs.load-config.outputs.config).notifications.enabled
        run: |
          chmod +x ./scripts/send_notifications.sh
          ./scripts/send_notifications.sh "${{ steps.status.outputs.status }}" "CI Pipeline" "${{ steps.status.outputs.message }}"
        env:
          CONFIG_JSON: '${{ needs.load-config.outputs.config }}'
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          EMAIL_SMTP_PASSWORD: ${{ secrets.EMAIL_SMTP_PASSWORD }}
